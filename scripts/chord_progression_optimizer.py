#!/usr/bin/env python3
"""
Brute Force Chord Progression Optimizer

Finds the optimal 4-chord progression that matches a target "Distance Curve"
while balancing voice leading smoothness and chord consonance.

Three Independent Weights (all components normalized 0-1):
    - Voice Leading: 0 = smooth (no movement), 1 = jumpy (max movement)
    - Roughness: 0 = consonant, 1 = dissonant  
    - Distance from Home: 0 = familiar (home key), 1 = remote (far from home)

Where:
    - Roughness: Based on RQA recurrence (inverse relationship - lower recurrence = higher roughness)
    - Distance: RQA-based spectral distance from home root note
    - Voice Leading: Minimum semitone movement between chord voicings
"""
import os
import random
from typing import List, Tuple, Dict

from audio_utils import generate_progression_audio, save_audio

# Note names
NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]

# Chord types (triads only - Major and minor)
CHORD_TYPES = ["Major", "minor"]

# Semitone intervals for chord types
CHORD_INTERVALS = {
    "Major": [0, 4, 7],  # Root, major 3rd, perfect 5th
    "minor": [0, 3, 7],  # Root, minor 3rd, perfect 5th
}

# RQA Recurrence values (normalized, unison=100) from rqa_all_roots.csv
# These represent consonance - higher = more consonant
RQA_RECURRENCE = {
    "unison": 100.0,
    "Major": 22.8,   # Average across roots
    "minor": 7.1,    # Average across roots
}

# RQA-based distance from home (C root note)
# Generated by rqa_distance_from_home.py using just intonation
# Uses boosted chord root (10x) to emphasize chord root ↔ home note relationship
# Higher distance = more dissonant with home root
RQA_DISTANCE_FROM_HOME = {
    "A#_Maj": 0.7697,
    "A#_min": 0.7385,
    "A_Maj": 0.3579,
    "A_min": 0.6417,
    "B_Maj": 0.7930,
    "B_min": 0.7854,
    "C#_Maj": 0.5036,
    "C#_min": 0.3243,
    "C_Maj": 0.0000,
    "C_min": 0.0544,
    "D#_Maj": 0.4172,
    "D#_min": 0.4120,
    "D_Maj": 0.4459,
    "D_min": 0.4353,
    "E_Maj": 0.4327,
    "E_min": 0.4562,
    "F#_Maj": 0.5745,
    "F#_min": 0.5325,
    "F_Maj": 0.1422,
    "F_min": 0.4336,
    "G#_Maj": 0.4823,
    "G#_min": 0.6620,
    "G_Maj": 0.5160,
    "G_min": 0.4820,
}


def get_roughness(chord_type: str) -> float:
    """
    Convert RQA recurrence to roughness (0.0 to 1.0).
    Higher recurrence = lower roughness (more consonant).
    
    Scale: unison (100) -> 0.0 roughness
           diminished (0.8) -> ~1.0 roughness
    
    For triads:
        Major (22.8) -> low roughness
        minor (7.1) -> moderate roughness
    """
    recurrence = RQA_RECURRENCE.get(chord_type, 10.0)
    # Normalize: 100 -> 0.0, 0 -> 1.0
    # Using log scale for better distribution
    if recurrence <= 0:
        return 1.0
    # Linear scale from 0-100 recurrence to 1.0-0.0 roughness
    roughness = 1.0 - (recurrence / 100.0)
    return max(0.0, min(1.0, roughness))


def get_spectral_distance(root: int, chord_type: str, home_root: int) -> float:
    """
    Get RQA-based spectral distance from home key (0.0 to 1.0).
    Uses pre-computed lookup table from rqa_distance_from_home.py.
    
    Falls back to circle of fifths if chord not in lookup table.
    """
    chord_name = format_chord_name(root, chord_type)
    
    # Use RQA-based distance if available
    if chord_name in RQA_DISTANCE_FROM_HOME:
        return RQA_DISTANCE_FROM_HOME[chord_name]
    
    # Fallback: circle of fifths distance
    circle_positions = {
        0: 0, 7: 1, 2: 2, 9: 3, 4: 4, 11: 5,
        6: 6, 1: 7, 8: 8, 3: 9, 10: 10, 5: 11,
    }
    
    pos_home = circle_positions[home_root % 12]
    pos_chord = circle_positions[root % 12]
    
    circle_dist = abs(pos_chord - pos_home)
    if circle_dist > 6:
        circle_dist = 12 - circle_dist
    
    return circle_dist / 6.0


def get_chord_notes(root: int, chord_type: str) -> List[int]:
    """Get MIDI note numbers for a chord (in octave 4, C4=60)."""
    base = 48 + root  # C4 + root offset
    intervals = CHORD_INTERVALS[chord_type]
    return [base + interval for interval in intervals]


def voice_leading_cost(chord1_notes: List[int], chord2_notes: List[int]) -> float:
    """
    Calculates the 'Smart Pianist' distance, normalized to 0-1.
    Assumes the player finds the closest inversion (minimized movement).
    
    Returns:
        Normalized voice leading cost (0.0 = no movement, 1.0 = maximum movement)
        Maximum possible movement for a triad is 18 semitones (3 notes × 6 semitones max each)
    """
    # 1. Convert everything to Pitch Classes (0-11)
    pc1 = [n % 12 for n in chord1_notes]
    pc2 = [n % 12 for n in chord2_notes]
    
    # 2. Find the best mapping (Greedy approach works well for triads)
    # We want to match every note in Chord A to the closest note in Chord B
    
    total_movement = 0.0
    
    # We create a copy of pc2 so we can "consume" notes as we match them
    # to avoid mapping two notes to the same destination if possible.
    remaining_targets = pc2.copy()
    
    for n1 in pc1:
        # Find the closest note in the remaining targets
        best_dist = 100
        best_target_idx = -1
        
        for i, n2 in enumerate(remaining_targets):
            # Calculate distance on the circle (0-6)
            # e.g. Distance between 0 (C) and 11 (B) is 1, not 11.
            diff = abs(n1 - n2)
            dist = min(diff, 12 - diff)
            
            if dist < best_dist:
                best_dist = dist
                best_target_idx = i
        
        # Add to total
        total_movement += best_dist
        
        # Remove the used target so other voices find their own path
        # (If lists are different lengths, handle gracefully)
        if best_target_idx != -1:
            remaining_targets.pop(best_target_idx)
    
    # Normalize to 0-1 range
    # Maximum movement for a triad: 3 notes × 6 semitones = 18
    max_movement = len(pc1) * 6
    normalized = total_movement / max_movement if max_movement > 0 else 0.0
    
    return max(0.0, min(1.0, normalized))


def format_chord_name(root: int, chord_type: str) -> str:
    """Format chord name like 'C_Maj' or 'A_min'."""
    note = NOTE_NAMES[root % 12]
    type_abbrev = "Maj" if chord_type == "Major" else "min"
    return f"{note}_{type_abbrev}"


def build_chord_database(home_root: int) -> List[Dict]:
    """
    Build database of all possible chords with their properties.
    Each chord has roughness (0-1), distance (0-1), and tension (0-1) pre-computed.
    Tension = (roughness + distance) / 2
    """
    chords = []
    for root in range(12):
        for chord_type in CHORD_TYPES:
            roughness = get_roughness(chord_type)
            distance = get_spectral_distance(root, chord_type, home_root)
            tension = (roughness + distance) / 2.0
            notes = get_chord_notes(root, chord_type)
            name = format_chord_name(root, chord_type)
            chords.append({
                "root": root,
                "type": chord_type,
                "roughness": roughness,
                "distance": distance,
                "tension": tension,
                "notes": notes,
                "name": name,
            })
    return chords


def find_home_chord(chords: List[Dict], home_root: int) -> Dict:
    """Find the home Major chord."""
    for chord in chords:
        if chord["root"] == home_root and chord["type"] == "Major":
            return chord
    return chords[0]


def brute_force_optimize(
    home_root: int = 0,
    target_curve: List[float] = None,
    voice_weight: float = 1.0,
    tension_weight: float = 1.0,
    temperature: float = 0.0,
) -> Tuple[List[Dict], float]:
    """
    Brute force search for optimal 4-chord progression.
    
    Scoring based on "resolution efficiency":
    - First chord: Match tension directly to target[0]
    - Subsequent chords: Match CHANGE in tension to target change
      - Resolution strength = |Δtension| / voice_leading_distance
      - Rewards achieving large tension changes with minimal voice movement
    
    Args:
        home_root: Root note of home key (0=C, 1=C#, etc.)
        target_curve: Target tension curve [t1, t2, t3, t4]
        voice_weight: Weight for resolution efficiency (higher = prefer efficient resolutions)
        tension_weight: Weight for tension change matching (higher = match target changes)
        temperature: Randomness factor (0.0 = deterministic, higher = more random)
    
    Returns:
        Tuple of (best_path, best_score)
    """
    if target_curve is None:
        target_curve = [0.0, 0.4, 0.9, 0.0]
    
    # Build chord database (with roughness, distance, and tension pre-computed)
    chords = build_chord_database(home_root)
    
    # Pre-compute target tension CHANGES
    target_changes = []
    for i in range(1, len(target_curve)):
        target_changes.append(target_curve[i] - target_curve[i-1])
    
    best_path = None
    best_score = float('inf')
    
    # For temperature-based selection, collect all candidates
    all_candidates = []
    
    # Small epsilon to avoid division by zero
    EPSILON = 0.01
    
    # Brute force: 4 nested loops for all chords (no fixed first chord)
    for c1 in chords:
        for c2 in chords:
            # Skip if same chord as previous
            if c2["name"] == c1["name"]:
                continue
            for c3 in chords:
                # Skip if same chord as previous
                if c3["name"] == c2["name"]:
                    continue
                for c4 in chords:
                    # Skip if same chord as previous
                    if c4["name"] == c3["name"]:
                        continue
                    path = [c1, c2, c3, c4]
                    
                    # === FIRST CHORD: Match tension directly ===
                    first_chord_cost = abs(target_curve[0] - path[0]["tension"])
                    
                    # === SUBSEQUENT CHORDS: Match tension CHANGES ===
                    tension_change_cost = 0.0
                    resolution_efficiency_bonus = 0.0
                    
                    for i in range(1, len(path)):
                        # Actual tension change
                        actual_change = path[i]["tension"] - path[i-1]["tension"]
                        target_change = target_changes[i-1]
                        
                        # Cost: how far off is our tension change from target?
                        tension_change_cost += abs(actual_change - target_change)
                        
                        # Voice leading distance for this transition
                        voice_dist = voice_leading_cost(path[i-1]["notes"], path[i]["notes"])
                        
                        # Resolution efficiency = |Δtension| / (voice_distance + epsilon)
                        # Higher is better (more tension change per semitone)
                        # We want to MAXIMIZE this, so we'll subtract it from cost
                        # or equivalently, add it as a bonus (negative cost)
                        efficiency = abs(actual_change) / (voice_dist + EPSILON)
                        resolution_efficiency_bonus += efficiency
                    
                    # Normalize costs
                    # First chord cost: 0-1 range
                    # Tension change cost: 3 transitions, each can differ by up to 2.0 (from -1 to +1)
                    # But typically much smaller, normalize by 3
                    tension_change_cost = tension_change_cost / 3.0
                    
                    # Efficiency bonus: higher = better, so we negate it
                    # Normalize: max efficiency per step is ~1.0/0.01 = 100 if no movement
                    # But realistically it's around 0-10, so divide by ~10 to get 0-1 range
                    # Then negate so lower score = better
                    efficiency_cost = -resolution_efficiency_bonus / 10.0
                    
                    # Total score with weights
                    base_score = (
                        (first_chord_cost * tension_weight) +
                        (tension_change_cost * tension_weight) +
                        (efficiency_cost * voice_weight)
                    )
                    
                    if temperature > 0:
                        # Add jitter for stochastic selection
                        jitter = random.gauss(0, temperature)
                        jittered_score = base_score + jitter
                        all_candidates.append((path, base_score, jittered_score))
                    else:
                        # Deterministic: just track best
                        if base_score < best_score:
                            best_score = base_score
                            best_path = path
    
    if temperature > 0:
        # Sort by jittered score and pick the best
        all_candidates.sort(key=lambda x: x[2])
        best_path, best_score, _ = all_candidates[0]
    
    return best_path, best_score


def print_progression(path: List[Dict], target_curve: List[float]):
    """Print the chord progression with details."""
    print("\n" + "=" * 70)
    print("OPTIMAL CHORD PROGRESSION")
    print("=" * 70)
    
    print("\nTarget Tension Curve:", target_curve)
    print("Tension = (Roughness + Distance) / 2")
    
    # Compute target changes
    target_changes = [target_curve[i] - target_curve[i-1] for i in range(1, len(target_curve))]
    print("Target Tension Changes:", [f"{c:+.3f}" for c in target_changes])
    
    print("\nBest Path Found:")
    print("-" * 70)
    
    EPSILON = 0.01
    result_strings = []
    
    # First chord: match tension directly
    chord = path[0]
    tension = chord["tension"]
    target = target_curve[0]
    diff = abs(target - tension)
    result_strings.append(f'"{chord["name"]} (T: {tension:.2f})"')
    print(f"  Step 1: {chord['name']:8s} | Tension: {tension:.3f} | Target: {target:.3f} | Diff: {diff:.3f}")
    
    # Subsequent chords: show tension change and resolution efficiency
    print("-" * 70)
    print("  Transitions (matching tension CHANGES):")
    total_change_diff = 0.0
    total_efficiency = 0.0
    
    for i in range(1, len(path)):
        chord = path[i]
        prev_chord = path[i-1]
        
        actual_change = chord["tension"] - prev_chord["tension"]
        target_change = target_changes[i-1]
        change_diff = abs(actual_change - target_change)
        total_change_diff += change_diff
        
        voice_dist = voice_leading_cost(prev_chord["notes"], chord["notes"])
        efficiency = abs(actual_change) / (voice_dist + EPSILON)
        total_efficiency += efficiency
        
        result_strings.append(f'"{chord["name"]} (T: {chord["tension"]:.2f})"')
        print(f"    {prev_chord['name']:8s} -> {chord['name']:8s} | "
              f"ΔTension: {actual_change:+.3f} (target: {target_change:+.3f}, diff: {change_diff:.3f}) | "
              f"Voice: {voice_dist:.3f} | Efficiency: {efficiency:.2f}")
    
    print("-" * 70)
    print(f"  Avg tension change diff: {total_change_diff / 3.0:.3f}")
    print(f"  Total resolution efficiency: {total_efficiency:.2f}")
    print(f"\nFormatted Output:")
    print(f"  [{', '.join(result_strings)}]")


def print_chord_tensions(home_root: int):
    """Print all chord properties for reference."""
    print("\n" + "=" * 60)
    print("CHORD PROPERTIES REFERENCE")
    print(f"Home Key: {NOTE_NAMES[home_root]}")
    print("=" * 60)
    print("\nAll values normalized to 0-1:")
    print("  - Tension = (Roughness + Distance) / 2")
    print("  - Roughness: 0 = consonant, 1 = dissonant")
    print("  - Distance:  0 = familiar (home), 1 = remote (far from home)")
    
    chords = build_chord_database(home_root)
    
    # Sort by tension
    chords_sorted = sorted(chords, key=lambda c: c["tension"])
    
    print(f"\n{'Chord':12s} | {'Tension':>8s} | {'Roughness':>10s} | {'Distance':>10s}")
    print("-" * 50)
    
    for chord in chords_sorted:
        print(f"{chord['name']:12s} | {chord['tension']:>8.3f} | {chord['roughness']:>10.3f} | {chord['distance']:>10.3f}")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Brute Force Chord Progression Optimizer"
    )
    parser.add_argument(
        "--home", type=int, default=0,
        help="Home root note (0=C, 1=C#, 2=D, etc.). Default: 0 (C)"
    )
    parser.add_argument(
        "--curve", type=float, nargs=4, default=[0.39, 0.46, 0.65, 0.39],

        # "--curve", type=float, nargs=4, default=[0.386, 0.4571, 0.644, 0.386],
        help="Target tension curve (4 values, 0-1). Default matches C-F-G-C: [0.386, 0.4571, 0.644, 0.386]"
    )
    parser.add_argument(
        "--voice-weight", type=float, default=0.0,
        help="Weight for resolution efficiency: higher=prefer large tension changes with small voice movement. Default: 0.5"
    )
    parser.add_argument(
        "--tension-weight", type=float, default=1,
        help="Weight for tension change matching: higher=match target tension changes. Default: 1.0"
    )
    parser.add_argument(
        "--temperature", type=float, default=0.05,
        help="Randomness/jitter factor. 0.0 = deterministic, higher = more random. Default: 0.0"
    )
    parser.add_argument(
        "--seed", type=int, default=None,
        help="Random seed for reproducibility when using temperature > 0"
    )
    parser.add_argument(
        "--show-tensions", action="store_true",
        help="Show all chord properties (roughness, distance) for reference"
    )
    parser.add_argument(
        "--output", type=str, default="results/progression.mp3",
        help="Output audio file path. Default: results/progression.mp3"
    )
    parser.add_argument(
        "--chord-duration", type=float, default=1.0,
        help="Duration of each chord in seconds. Default: 1.0"
    )
    parser.add_argument(
        "--no-audio", action="store_true",
        help="Skip audio file generation"
    )
    
    args = parser.parse_args()
    
    home_root = args.home % 12
    target_curve = args.curve
    
    print(f"\nBrute Force Chord Progression Optimizer")
    print(f"Home Key: {NOTE_NAMES[home_root]}")
    print(f"Target Tension Curve: {target_curve}")
    print(f"\nWeights (all components normalized 0-1):")
    print(f"  Voice Leading: {args.voice_weight} (0=ignore, higher=prefer smooth)")
    print(f"  Tension:       {args.tension_weight} (0=ignore, higher=match target curve)")
    print(f"Temperature: {args.temperature}")
    
    # Set random seed if provided
    if args.seed is not None:
        random.seed(args.seed)
        print(f"Random Seed: {args.seed}")
    
    if args.show_tensions:
        print_chord_tensions(home_root)
    
    # Run optimizer
    print("\nSearching for optimal progression...")
    best_path, best_score = brute_force_optimize(
        home_root=home_root,
        target_curve=target_curve,
        voice_weight=args.voice_weight,
        tension_weight=args.tension_weight,
        temperature=args.temperature,
    )
    
    print(f"Best Total Score: {best_score:.4f}")
    print_progression(best_path, target_curve)
    
    # Generate audio
    if not args.no_audio:
        print("\nGenerating audio...")
        
        audio = generate_progression_audio(
            path=best_path,
            chord_duration=args.chord_duration,
        )
        
        save_audio(audio, args.output)


if __name__ == "__main__":
    main()
