#!/usr/bin/env python3
"""
Brute Force Chord Progression Optimizer

Finds the optimal 4-chord progression that matches a target "Distance Curve"
while balancing voice leading smoothness and chord consonance.

Three Independent Weights (all components normalized 0-1):
    - Voice Leading: 0 = smooth (no movement), 1 = jumpy (max movement)
    - Roughness: 0 = consonant, 1 = dissonant  
    - Distance from Home: 0 = familiar (home key), 1 = remote (far from home)

Where:
    - Roughness: Based on RQA recurrence (inverse relationship - lower recurrence = higher roughness)
    - Distance: RQA-based spectral distance from home root note
    - Voice Leading: Minimum semitone movement between chord voicings
"""
import os
import random
from typing import List, Tuple, Dict

from audio_utils import generate_progression_audio, save_audio

# Note names
NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]

# Chord types (triads only - Major and minor)
CHORD_TYPES = ["Major", "minor"]

# Semitone intervals for chord types
CHORD_INTERVALS = {
    "Major": [0, 4, 7],  # Root, major 3rd, perfect 5th
    "minor": [0, 3, 7],  # Root, minor 3rd, perfect 5th
}

# RQA Recurrence values (normalized, unison=100) from rqa_all_roots.csv
# These represent consonance - higher = more consonant
RQA_RECURRENCE = {
    "unison": 100.0,
    "Major": 22.8,   # Average across roots
    "minor": 7.1,    # Average across roots
}

# RQA-based distance from home (C root note)
# Generated by rqa_distance_from_home.py using just intonation
# Uses boosted chord root (10x) to emphasize chord root ↔ home note relationship
# Higher distance = more dissonant with home root
RQA_DISTANCE_FROM_HOME = {
    "A#_Maj": 0.7697,
    "A#_min": 0.7385,
    "A_Maj": 0.3579,
    "A_min": 0.6417,
    "B_Maj": 0.7930,
    "B_min": 0.7854,
    "C#_Maj": 0.5036,
    "C#_min": 0.3243,
    "C_Maj": 0.0000,
    "C_min": 0.0544,
    "D#_Maj": 0.4172,
    "D#_min": 0.4120,
    "D_Maj": 0.4459,
    "D_min": 0.4353,
    "E_Maj": 0.4327,
    "E_min": 0.4562,
    "F#_Maj": 0.5745,
    "F#_min": 0.5325,
    "F_Maj": 0.1422,
    "F_min": 0.4336,
    "G#_Maj": 0.4823,
    "G#_min": 0.6620,
    "G_Maj": 0.5160,
    "G_min": 0.4820,
}


def get_roughness(chord_type: str) -> float:
    """
    Convert RQA recurrence to roughness (0.0 to 1.0).
    Higher recurrence = lower roughness (more consonant).
    
    Scale: unison (100) -> 0.0 roughness
           diminished (0.8) -> ~1.0 roughness
    
    For triads:
        Major (22.8) -> low roughness
        minor (7.1) -> moderate roughness
    """
    recurrence = RQA_RECURRENCE.get(chord_type, 10.0)
    # Normalize: 100 -> 0.0, 0 -> 1.0
    # Using log scale for better distribution
    if recurrence <= 0:
        return 1.0
    # Linear scale from 0-100 recurrence to 1.0-0.0 roughness
    roughness = 1.0 - (recurrence / 100.0)
    return max(0.0, min(1.0, roughness))


def get_spectral_distance(root: int, chord_type: str, home_root: int) -> float:
    """
    Get RQA-based spectral distance from home key (0.0 to 1.0).
    Uses pre-computed lookup table from rqa_distance_from_home.py.
    
    Falls back to circle of fifths if chord not in lookup table.
    """
    chord_name = format_chord_name(root, chord_type)
    
    # Use RQA-based distance if available
    if chord_name in RQA_DISTANCE_FROM_HOME:
        return RQA_DISTANCE_FROM_HOME[chord_name]
    
    # Fallback: circle of fifths distance
    circle_positions = {
        0: 0, 7: 1, 2: 2, 9: 3, 4: 4, 11: 5,
        6: 6, 1: 7, 8: 8, 3: 9, 10: 10, 5: 11,
    }
    
    pos_home = circle_positions[home_root % 12]
    pos_chord = circle_positions[root % 12]
    
    circle_dist = abs(pos_chord - pos_home)
    if circle_dist > 6:
        circle_dist = 12 - circle_dist
    
    return circle_dist / 6.0


def get_chord_notes(root: int, chord_type: str) -> List[int]:
    """Get MIDI note numbers for a chord (in octave 4, C4=60)."""
    base = 48 + root  # C4 + root offset
    intervals = CHORD_INTERVALS[chord_type]
    return [base + interval for interval in intervals]


def midi_to_freq(midi_note: int) -> float:
    """Convert MIDI note number to frequency in Hz."""
    return 440.0 * (2 ** ((midi_note - 69) / 12))


def freq_to_continuous_semitone(freq: float) -> float:
    """
    Converts Hz to a continuous semitone scale (relative to MIDI 0).
    Formula: 69 + 12 * log2(freq / 440)
    
    This allows handling microtones and non-standard tuning.
    """
    import math
    if freq <= 0:
        return 0
    return 69 + 12 * math.log2(freq / 440.0)


def voice_leading_cost_freq(chord1_freqs: List[float], chord2_freqs: List[float]) -> float:
    """
    Calculates voice leading distance for raw frequencies (Hz).
    Handles microtones and non-standard tuning.
    
    Human hearing is logarithmic, so we convert Hz to continuous semitones
    before calculating distance. This ensures a "Perfect 5th" jump costs
    the same in bass as in treble.
    
    Returns:
        Total semitone movement (as float, handles microtones)
    """
    import math
    
    # 1. Convert Hz to Continuous Semitones
    # This ensures that a "Perfect 5th" jump costs the same in Bass as in Treble.
    # We use floating point numbers now, not integers.
    pitch1 = [freq_to_continuous_semitone(f) for f in chord1_freqs]
    pitch2 = [freq_to_continuous_semitone(f) for f in chord2_freqs]

    # 2. Convert to "Pitch Class" (0.0 to 11.999...)
    # We use modulo 12.0 to wrap everything into one octave
    pc1 = [p % 12.0 for p in pitch1]
    pc2 = [p % 12.0 for p in pitch2]

    total_movement = 0.0
    remaining_targets = pc2.copy()

    # 3. Greedy Matching (adapted for float)
    for p1 in pc1:
        best_dist = 100.0
        best_target_idx = -1

        for i, p2 in enumerate(remaining_targets):
            # Calculate Circular Distance
            diff = abs(p1 - p2)
            
            # Shortest path on the circle (e.g. 0.1 to 11.9 is distance 0.2, not 11.8)
            dist = min(diff, 12.0 - diff)

            if dist < best_dist:
                best_dist = dist
                best_target_idx = i

        total_movement += best_dist

        if best_target_idx != -1:
            remaining_targets.pop(best_target_idx)

    return total_movement


# def voice_leading_cost(chord1_notes: List[int], chord2_notes: List[int]) -> float:
#     """
#     Calculates the 'Smart Pianist' distance in raw semitones.
#     Assumes the player finds the closest inversion (minimized movement).
#     
#     Returns:
#         Total semitone movement (not normalized)
#     """
#     import math
#     
#     # 1. Convert everything to Pitch Classes (0-11)
#     pc1 = [n % 12 for n in chord1_notes]
#     pc2 = [n % 12 for n in chord2_notes]
#     
#     # 2. Find the best mapping (Greedy approach works well for triads)
#     # We want to match every note in Chord A to the closest note in Chord B
#     
#     total_movement = 0.0
#     
#     # We create a copy of pc2 so we can "consume" notes as we match them
#     # to avoid mapping two notes to the same destination if possible.
#     remaining_targets = pc2.copy()
#     
#     for n1 in pc1:
#         # Find the closest note in the remaining targets
#         best_dist = 100
#         best_target_idx = -1
#         
#         for i, n2 in enumerate(remaining_targets):
#             # Calculate distance on the circle (0-6)
#             # e.g. Distance between 0 (C) and 11 (B) is 1, not 11.
#             diff = abs(n1 - n2)
#             dist = min(diff, 12 - diff)
#             
#             if dist < best_dist:
#                 best_dist = dist
#                 best_target_idx = i
#         
#         # Add to total
#         total_movement += best_dist
#         
#         # Remove the used target so other voices find their own path
#         # (If lists are different lengths, handle gracefully)
#         if best_target_idx != -1:
#             remaining_targets.pop(best_target_idx)
#     
#     return total_movement


def soft_voice_leading_denominator(voice_distance: float) -> float:
    """
    Soft denominator for tension rate calculation.
    Uses logarithmic scaling to avoid punishing larger voice movements too hard.
    
    Formula: (log2(voice_distance) + 1) / 4
    
    Result: Average denominator is around 1, so rates are more intuitive.
    """
    import math
    if voice_distance < 1e-5:
        return 1.0
    return (math.log2(voice_distance) + 1) / 4


def format_chord_name(root: int, chord_type: str) -> str:
    """Format chord name like 'C_Maj' or 'A_min'."""
    note = NOTE_NAMES[root % 12]
    type_abbrev = "Maj" if chord_type == "Major" else "min"
    return f"{note}_{type_abbrev}"


def get_roman_numeral(root: int, chord_type: str, home_root: int) -> str:
    """
    Convert chord to Roman numeral notation relative to home key.
    
    Major chords: I, II, III, IV, V, VI, VII (uppercase)
    Minor chords: i, ii, iii, iv, v, vi, vii (lowercase)
    
    Accidentals shown with ♭ or ♯ prefix.
    """
    # Scale degrees in semitones from root
    scale_degrees = {
        0: "I",    # Unison
        1: "♭II",  # Minor 2nd
        2: "II",   # Major 2nd
        3: "♭III", # Minor 3rd
        4: "III",  # Major 3rd
        5: "IV",   # Perfect 4th
        6: "♯IV",  # Tritone (could also be ♭V)
        7: "V",    # Perfect 5th
        8: "♭VI",  # Minor 6th
        9: "VI",   # Major 6th
        10: "♭VII", # Minor 7th
        11: "VII",  # Major 7th
    }
    
    # Calculate interval from home root
    interval = (root - home_root) % 12
    
    roman = scale_degrees[interval]
    
    # Lowercase for minor chords
    if chord_type == "minor":
        roman = roman.lower()
    
    return roman


def build_chord_database(home_root: int) -> List[Dict]:
    """
    Build database of all possible chords with their properties.
    Each chord has roughness (0-1), distance (0-1), and tension (0-1) pre-computed.
    Tension = distance
    """
    chords = []
    for root in range(12):
        for chord_type in CHORD_TYPES:
            roughness = get_roughness(chord_type)
            distance = get_spectral_distance(root, chord_type, home_root)
            tension = distance
            notes = get_chord_notes(root, chord_type)
            name = format_chord_name(root, chord_type)
            roman = get_roman_numeral(root, chord_type, home_root)
            chords.append({
                "root": root,
                "type": chord_type,
                "roughness": roughness,
                "distance": distance,
                "tension": tension,
                "notes": notes,
                "name": name,
                "roman": roman,
            })
    return chords


def find_home_chord(chords: List[Dict], home_root: int) -> Dict:
    """Find the home Major chord."""
    for chord in chords:
        if chord["root"] == home_root and chord["type"] == "Major":
            return chord
    return chords[0]


def brute_force_optimize(
    home_root: int = 0,
    target_curve: List[float] = None,
    voice_weight: float = 1.0,
    tension_weight: float = 1.0,
    temperature: float = 0.0,
) -> Tuple[List[Dict], float]:
    """
    Brute force search for optimal 4-chord progression.
    
    Solves for: ΔTension / ΔVoiceLeading ≈ Target Slope
    
    The algorithm matches the RATE of tension change per semitone of voice movement
    to the target slope at each step.
    
    Args:
        home_root: Root note of home key (0=C, 1=C#, etc.)
        target_curve: Target tension curve [t1, t2, t3, t4]
        voice_weight: (unused in rate-matching mode)
        tension_weight: (unused in rate-matching mode)
        temperature: Randomness factor (0.0 = deterministic, higher = more random)
    
    Returns:
        Tuple of (best_path, best_score)
    """
    if target_curve is None:
        target_curve = [0.0, 0.4, 0.9, 0.0]
    
    # Build chord database (with roughness, distance, and tension pre-computed)
    chords = build_chord_database(home_root)
    
    # Pre-calculate the slopes of the target curve
    # Example: [0, 0.4, 0.8, 0] -> Slopes: [+0.4, +0.4, -0.8]
    target_slopes = [target_curve[i] - target_curve[i-1] for i in range(1, len(target_curve))]
    
    best_path = None
    best_score = float('inf')
    
    # For temperature-based selection, collect all candidates
    all_candidates = []
    
    # Brute force: 4 nested loops for all chords
    for c1 in chords:
        for c2 in chords:
            if c2["name"] == c1["name"]:
                continue
            for c3 in chords:
                if c3["name"] == c2["name"]:
                    continue
                for c4 in chords:
                    if c4["name"] == c3["name"]:
                        continue
                    
                    path = [c1, c2, c3, c4]
                    path_cost = 0.0
                    
                    # Iterate through the transitions (Steps 1, 2, 3)
                    for i in range(1, len(path)):
                        
                        # A. Get the Target Slope for this specific step
                        target_slope = target_slopes[i-1]
                        
                        # B. Calculate Actual Change in Tension
                        d_tension = path[i]["tension"] - path[i-1]["tension"]
                        
                        # C. Calculate Voice Leading Distance (in semitones)
                        # Convert MIDI notes to frequencies for voice_leading_cost_freq
                        freq1 = [midi_to_freq(n) for n in path[i-1]["notes"]]
                        freq2 = [midi_to_freq(n) for n in path[i]["notes"]]
                        d_voice = voice_leading_cost_freq(freq1, freq2)
                        
                        # D. Use soft denominator to avoid punishing larger moves too hard
                        # Formula: log2(voice_distance + 1) + 1
                        soft_denom = soft_voice_leading_denominator(d_voice)
                        
                        # E. Calculate Actual Rate with soft denominator
                        # "How much tension did we gain per unit of (soft) voice movement?"
                        actual_rate = d_tension / soft_denom
                        
                        # F. Add penalty for deviation from target slope
                        path_cost += abs(actual_rate - target_slope)
                    
                    # F. Check if this is the best "flow" so far
                    if temperature > 0:
                        jitter = random.gauss(0, temperature)
                        jittered_score = path_cost + jitter
                        all_candidates.append((path, path_cost, jittered_score))
                    else:
                        if path_cost < best_score:
                            best_score = path_cost
                            best_path = path
    
    if temperature > 0:
        # Sort by jittered score and pick the best
        all_candidates.sort(key=lambda x: x[2])
        best_path, best_score, _ = all_candidates[0]
    
    return best_path, best_score


def print_progression(path: List[Dict], target_curve: List[float]):
    """Print the chord progression with rate-matching details."""
    print("\n" + "=" * 70)
    print("OPTIMAL CHORD PROGRESSION")
    print("=" * 70)
    
    print("\nTarget Tension Curve:", target_curve)
    print("Tension = (Roughness + Distance) / 2")
    
    # Compute target slopes
    target_slopes = [target_curve[i] - target_curve[i-1] for i in range(1, len(target_curve))]
    print("Target Slopes (ΔTension):", [f"{s:+.3f}" for s in target_slopes])
    
    print("\nBest Path Found:")
    print("-" * 70)
    
    result_strings = []
    roman_strings = []
    
    # First chord
    chord = path[0]
    result_strings.append(f'"{chord["name"]} (T: {chord["tension"]:.2f})"')
    roman_strings.append(chord["roman"])
    print(f"  Step 1: {chord['roman']:8s} ({chord['name']:8s}) | Tension: {chord['tension']:.3f}")
    
    # Transitions: show rate matching
    print("-" * 70)
    print("  Transitions (using soft denominator: log2(ΔV + 1) + 1):")
    total_rate_cost = 0.0
    
    for i in range(1, len(path)):
        chord = path[i]
        prev_chord = path[i-1]
        
        target_slope = target_slopes[i-1]
        d_tension = chord["tension"] - prev_chord["tension"]
        # Convert MIDI notes to frequencies for voice_leading_cost_freq
        freq1 = [midi_to_freq(n) for n in prev_chord["notes"]]
        freq2 = [midi_to_freq(n) for n in chord["notes"]]
        d_voice = voice_leading_cost_freq(freq1, freq2)
        soft_denom = soft_voice_leading_denominator(d_voice)
        actual_rate = d_tension / soft_denom
        rate_diff = abs(actual_rate - target_slope)
        total_rate_cost += rate_diff
        
        result_strings.append(f'"{chord["name"]} (T: {chord["tension"]:.2f})"')
        roman_strings.append(chord["roman"])
        print(f"    {prev_chord['roman']:8s} -> {chord['roman']:8s} | "
              f"ΔT: {d_tension:+.3f} | ΔV: {d_voice:.0f} (soft: {soft_denom:.2f}) | "
              f"Rate: {actual_rate:+.3f} (target: {target_slope:+.3f}, diff: {rate_diff:.3f})")
    
    print("-" * 70)
    print(f"  Total rate cost: {total_rate_cost:.3f}")
    print(f"\nProgression (Roman Numerals): {' - '.join(roman_strings)}")
    print(f"Progression (Chord Names):    {' - '.join([c['name'] for c in path])}")
    print(f"\nFormatted Output:")
    print(f"  [{', '.join(result_strings)}]")


def print_chord_tensions(home_root: int):
    """Print all chord properties for reference."""
    print("\n" + "=" * 70)
    print("CHORD PROPERTIES REFERENCE")
    print(f"Home Key: {NOTE_NAMES[home_root]}")
    print("=" * 70)
    print("\nAll values normalized to 0-1:")
    print("  - Tension = (Roughness + Distance) / 2")
    print("  - Roughness: 0 = consonant, 1 = dissonant")
    print("  - Distance:  0 = familiar (home), 1 = remote (far from home)")
    
    chords = build_chord_database(home_root)
    
    # Sort by tension
    chords_sorted = sorted(chords, key=lambda c: c["tension"])
    
    print(f"\n{'Roman':8s} | {'Chord':12s} | {'Tension':>8s} | {'Roughness':>10s} | {'Distance':>10s}")
    print("-" * 60)
    
    for chord in chords_sorted:
        print(f"{chord['roman']:8s} | {chord['name']:12s} | {chord['tension']:>8.3f} | {chord['roughness']:>10.3f} | {chord['distance']:>10.3f}")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Brute Force Chord Progression Optimizer"
    )
    parser.add_argument(
        "--home", type=int, default=0,
        help="Home root note (0=C, 1=C#, 2=D, etc.). Default: 0 (C)"
    )
    parser.add_argument(
        "--curve", type=float, nargs=4, default=[0.0, 0.2, 0.65, -0.1],

        # "--curve", type=float, nargs=4, default=[0.386, 0.4571, 0.644, 0.386],
        help="Target tension curve (4 values, 0-1). Default matches C-F-G-C: [0.386, 0.4571, 0.644, 0.386]"
    )
    parser.add_argument(
        "--voice-weight", type=float, default=0.0,
        help="Weight for resolution efficiency: higher=prefer large tension changes with small voice movement. Default: 0.5"
    )
    parser.add_argument(
        "--tension-weight", type=float, default=1,
        help="Weight for tension change matching: higher=match target tension changes. Default: 1.0"
    )
    parser.add_argument(
        "--temperature", type=float, default=0.01,
        help="Randomness/jitter factor. 0.0 = deterministic, higher = more random. Default: 0.0"
    )
    parser.add_argument(
        "--seed", type=int, default=None,
        help="Random seed for reproducibility when using temperature > 0"
    )
    parser.add_argument(
        "--show-tensions", action="store_true",
        help="Show all chord properties (roughness, distance) for reference"
    )
    parser.add_argument(
        "--output", type=str, default="results/progression.mp3",
        help="Output audio file path. Default: results/progression.mp3"
    )
    parser.add_argument(
        "--chord-duration", type=float, default=1.0,
        help="Duration of each chord in seconds. Default: 1.0"
    )
    parser.add_argument(
        "--no-audio", action="store_true",
        help="Skip audio file generation"
    )
    
    args = parser.parse_args()
    
    home_root = args.home % 12
    target_curve = args.curve
    
    print(f"\nBrute Force Chord Progression Optimizer")
    print(f"Home Key: {NOTE_NAMES[home_root]}")
    print(f"Target Tension Curve: {target_curve}")
    print(f"\nWeights (all components normalized 0-1):")
    print(f"  Voice Leading: {args.voice_weight} (0=ignore, higher=prefer smooth)")
    print(f"  Tension:       {args.tension_weight} (0=ignore, higher=match target curve)")
    print(f"Temperature: {args.temperature}")
    
    # Set random seed if provided
    if args.seed is not None:
        random.seed(args.seed)
        print(f"Random Seed: {args.seed}")
    
    if args.show_tensions:
        print_chord_tensions(home_root)
    
    # Run optimizer
    print("\nSearching for optimal progression...")
    best_path, best_score = brute_force_optimize(
        home_root=home_root,
        target_curve=target_curve,
        voice_weight=args.voice_weight,
        tension_weight=args.tension_weight,
        temperature=args.temperature,
    )
    
    print(f"Best Total Score: {best_score:.4f}")
    print_progression(best_path, target_curve)
    
    # Generate audio
    if not args.no_audio:
        print("\nGenerating audio...")
        
        audio = generate_progression_audio(
            path=best_path,
            chord_duration=args.chord_duration,
        )
        
        save_audio(audio, args.output)


if __name__ == "__main__":
    main()
